;; _______BUILT IN_______
;; __INSTRUCTIONS__
;; set.c <address> <character>                  sets value into address (character)
;; set.n <address> <number>                     sets value into address (number)
;; set.s <startAddress> <string>                Adds a null terminated string starting at the startAddress
;; set.a <addressA> <variable>                  Sets the value of addressA to the address of a variable (for pointers)

;; out.r <address>                              outputs at address
;; out.b <address>                              outputs True or False at address
;; wrt.s <string>                               write string
;; wrt.n                                        Writes a null character
;; out.l <startAddress> <n>                     outputs n addresses starting at startAddress
;; out.n <startAddress>                         outputs all memory addresses incrementally till it hits null
;; in.c <address>                               Saves a input character to the address
;; cpy <addressA> <addressB>                    copies addressA to addressB
;; mpl <addressA> <addressB> <addressC>         multiplies addressA and addressB and stores in addressC
;; add <addressA> <addressB> <addressC>         adds addressA and addressB and stores in addressC
;; sub <addressA> <addressB> <addressC>         subtracts addressA from addressB and stores in addressC
;; jmp <label>                                  jumps to a label
;; jmp.nz <address> <label>                     jumps to a label if address is not zero
;; jmp.ez <address> <label>                     jumps to a label if address is zero
;; inc <address>                                increments value at address
;; dec <address>                                decrements value at address
;; raw <startAddress> <brainfuck code>          Embeds raw brainfuck code into the compiled code (dangerous).
;;
;; __GATES__
;; and <addressA> <addressB> <addressC>         AND gate    if a and b then c is 1
;; nand <addressA> <addressB> <addressC>        NAND gate   if a and b then c is 0 else 1
;; or <addressA> <addressB> <addressC>          OR gate     if a or b then c is 1
;; xor <addressA> <addressB> <addressC>         XOR gate    if a and b are different then c is 1
;; not <addressA> <addressB>                    NOT gate    if a is 1 then b is 0 and vice versa
;;
;; dbg                                          Shows debug output on brainfuck helper vsc extension

;; __DEFINING VARIABLES__
;; sad <address> <name>                         gives an address a name you can use and access with '$name' on everything that uses addresses
;; __CONSTANTS
;; $cebf_compiler_0; $cebf_compiler_1 $cebf_compiler_2          Internal compiler addresses, use with caution!!! See compiler code for address explenation

;; __RESERVED CHARACTERS__
;;     ^: space

;; __MACROS__
;; macro <name> <argumentCount>                                 starts a macro. Use $0 $1 $2 ... to get the arguments of your macro
;; macroend                                                     End of a macro
;; calling a macro: <macro name> <arg0> <arg1> <arg2> ...

;; __INCLUDES__
;; #include <file/lib name>                     Includes a file from the local file system or standard libraries by replacing the include with the file content

;; __COMPILER FLAGS__
;;   Make comments with ;;
;;   Add #nocomment to strip the all comments from this file
;;   Add #minify to strip all line breaks and compiler added comments from the finished code
;;   Add #commentcode to let the compiler comment the brainfuck code
;;   Add #noomovement to stop the compiler from optimizing the pointer movement
;;   Add #seperatestatemachine to put the state machine code into seperate lines


;; _______STANDARD LIBRARY________
;; include the standard library by adding '#include standard.cebf' to the top of your file

;; __FUNCTIONS__
;;
;; jmp.eq <addressA> <addressB> <label>     jumps to a label if addressA is equal to addressB


#nocomment
#omovement
;;#commentcode


;; set a and b variable names
sad 0 fortyeight
sad 1 a
sad 2 b
sad 3 res

;; zahlen als string einlesen
ous Zahl 1: 
inc $a
ous Zahl 2:
inc $b

;; remove 48 from a and b
stn 48 $fortyeight
sub $fortyeight $a 4
sub $fortyeight $b 5

;; multiply
mpl 4 5 $res

;; move pointer to result
mov $res